---
title: Core Concepts
description: Definitions for the foundational terms used across the plgg monorepo
category: developer
last_updated: 2026-02-26
commit_hash: ddbb696
---

[English](core-concepts.md) | [Japanese](core-concepts_ja.md)

# Core Concepts

## plgg

plgg is the root package of the monorepo and also the name of the overall project. As a package, `plgg` (at `src/plgg/`) provides a TypeScript functional programming type system and pipeline primitive library organized into eleven named categories: Abstracts, Atomics, Basics, Collectives, Conjunctives, Contextuals, Disjunctives, Exceptionals, Flowables, Functionals, and Grammaticals. As a project name, "plgg" refers to the entire monorepo hosted at `github.com/qmu/plgg`, which contains the `plgg`, `plgg-foundry`, and `plgg-kit` packages along with an unpublished `example` package. The project is explicitly marked UNSTABLE and is primarily intended for internal use.

## plgg-foundry

plgg-foundry is the AI-driven workflow orchestration package located at `src/plgg-foundry/`. It accepts a `Foundry` configuration (a collection of named `Apparatus` units) and an `Order` (natural-language instruction), then uses an LLM provider to generate an `Alignment` (structured operation plan), and executes that plan against the registered apparatuses. The public API is `runFoundry(foundry)(order)`, which composes the `blueprint` and `operate` functions internally. plgg-foundry depends on `plgg` for its type system and on `plgg-kit` for LLM provider access.

## plgg-kit

plgg-kit is the LLM vendor abstraction package located at `src/plgg-kit/`. It defines a `Provider` union type (`OpenAI | Anthropic | Google`), each constructed via a factory function (`openai()`, `anthropic()`, `google()`). The primary export is a `generateObject` function that dispatches to the appropriate vendor adapter based on the provider type. plgg-kit was extracted from `plgg-foundry` to allow independent reuse of LLM access without depending on the full workflow orchestration layer.

## apparatus

An apparatus is the unit of callable behavior registered in a `Foundry` configuration. It is a `Box` union of three variants: `Processor` (executes a function and maps named inputs/outputs through a register), `Switcher` (executes a boolean-returning function and branches on the result), and `Packer` (specifies an output field for egress). Apparatuses are named and collected in the `apparatuses` field of a `Foundry`. When an `Alignment` is executed, each `Operation` in the plan references apparatus names to look up and invoke the corresponding logic.

## alignment

An alignment is the structured operation plan generated by the `blueprint` function in plgg-foundry. It is an `Obj<{analysis, ingress, operations, egress}>` produced by an LLM from an `Order` input. The `ingress` field defines the entry point, `operations` is a sequence of `Assign | Process | Switch` nodes, and `egress` collects named register values as output. The alignment serves as the intermediate representation between a natural-language request and the register-based execution model in `operate`.

## order

An order is the natural-language instruction passed to `runFoundry` as input. It is typed as an `Obj` with fields defined by the foundry's order schema. The order is passed to the `blueprint` function, which forwards it to the LLM provider to produce an `Alignment`. The term "order" is used within plgg-foundry to distinguish the user's intent (the order) from the execution plan (the alignment) and the result.

## result

Result is a discriminated union type from the `plgg` Disjunctives category, defined as `Ok<T> | Err<E>`. It represents computations that may succeed or fail without throwing exceptions. The pattern-matching API uses `ok$` and `err$` constructors and the `match` function from Flowables for exhaustive handling. Throughout the codebase, functions that may fail return `Result` or `PromisedResult<T, E>` (an async variant), enforcing explicit error handling at every call site.

## pipe

pipe is the core synchronous pipeline composition function from `plgg`'s Flowables category. It takes an initial value and a sequence of functions, passing the output of each as the input to the next. Related pipeline primitives include `cast` (which chains Result-returning functions and short-circuits on `Err`), `proc` (which chains async Procedural-returning functions), and `flow` (which creates a point-free pipeline without an initial value).

## brand

A brand is a compile-time nominal type marker applied to a base type using `Brand<T, B>` from `plgg`'s Grammaticals category. Branded types prevent accidental assignment between structurally compatible but semantically distinct values. For example, `Str` is a branded string distinct from a plain `string`. Most types exported by plgg Atomics and Basics are branded.
